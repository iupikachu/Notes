## 汇编

```assembly
assume cs:codesg,ds:datasg

datasg segment
	db 'BaSiC'
	db 'iNfOrMaTion'
datasg ends

codesg segment
	start: mov ax,datasg
				 mov ds,ax
				 mov bx,0   					# 设置 bx = 0, ds:bx 指向'BaSiC'的第一个字母
				 mov cx,5   					# 设置 循环次数:5 'BaSiC' 有5个字母
			s: mov al,[bx] 					# 将ascii 码从 ds:bx 指向的单元中取出
				 and al,11011111B  	 	# 将 al 中的 ASCII 码第五个位置为0 变为大写字母
				 mov [bx],al          # 将转变后的 ASCII 码写回原单元
				 inc bx               # bx + 1 ds:bx 指向下一个字母
				 loop s
				 
				 mov bx = 5 					# ds:bx 指向'iNfOrMaTion'的第一个字母
				 mov cx,11            # 设置循环次数11 'iNfOrMaTion' 有11个字母
				 
			s0:mov al,[bx]
				 or al 00100000B					# al 中的 ASCII 码第五个位置为1，变为小写字母
				 mov [bx],al
				 inc bx
				 loop s0
				 
				 mov ax,4c00h
				 int 21h

codesg ends
end start
				 
			
```





用 [bx + idata] 完成上面的代码

```assembly
mov ax,datasg
mov ds,ax

mov bx,0
mov cx,5

s: mov al,[bx]
	 and al 11011111b
	 mov [bx],al
	 mov al,[5+bx]
	 or al,00100000b
	 mov [5+bx],al
	 inc bx
	 loop s


```

