





## JVM



### 1.前言

#### 1. 1 java代码如何运行?

![image-20210309163548308](JVM.assets/image-20210309163548308.png)

.java              .class              01100101  

 java代码    -》  java 字节码 -》机器码

​                打包                 JVM 

#### 1.2 类加载到使用过程 （.class 字节码文件加载到 JVM内存中）



> **加载    验证   准备  解析  初始化 使用 卸载**

  实用角度简单解析

* 验证  .class 文件内容是否符合JVM规范
* 准备   类变量(static 修饰的变量)分配内存空间 赋默认的初始值
* 解析   (很复杂,符号引用替换为实际引用)
* 初始化 （核心阶段） 执行类的初始化代码块（static代码块）



**什么时候初始化一个类?**

1. new 实例化对象时，触发类的加载到初始化的全过程
2. 包含main方法的主类，必须立马初始化好
3. 初始化类时，他的父类没有初始化，就必须先初始化他的父类



#### 1.3  什么情况会加载一个类?

1. 类有main方法作为程序主入口

2. 代码执行用到某个类的时候

   



#### 1.4  类加载器和双亲委派机制



**1.启动类加载器**

BootStrap ClassLoader  加载java目录下的核心类 （java安装目录下的"lib"目录）java最核心的类库，支撑java系统运行

一旦jvm启动，首先就会依托启动类加载器。



**2.扩展类加载器**

Extension ClassLoader  java安装目录下有 "lib/ext"目录，就是用它来加载，支撑系统运行。



**3.应用程序类加载器**

Application ClassLoader 复制加载 "ClassPath" 环境变量所指定的路径的类 （大致理解为加载自己写好的Java代码）



**4.自定义类加载器**

根据自己的需求加载



![image-20210309162656294](JVM.assets/image-20210309162656294.png)



![image-20210309162801953](JVM.assets/image-20210309162801953.png)

​		

**双亲委派流程:**

​	当一个Hello.class这样的文件要被加载时。不考虑我们自定义类加载器，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的loadClass方法。父类中同理也会先检查自己是否已经加载过，如果没有再往上。注意这个类似递归的过程，直到到达Bootstrap classLoader之前，都是在检查是否加载过，并不会选择自己去加载。直到BootstrapClassLoader，已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出ClassNotFoundException。

**双亲委派模式优势**

**避免重复加载 + 避免核心类篡改**
	采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心JavaAPI发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。



>**为什么必须要一级一级类加载器的往上找，直接从顶层类加载器开始找不就行了吗？**

​	其实关于这个问题，不用过于纠结，每一层类加载器对某个类的加载，上推给父类加载器，到顶层类加载器，如果发现自己加载不到，再下推回子类加载器来加载，这样可以保证绝对不会重复加载某个类。至于为什么不直接从顶层类加载器开始找，那是因为类加载器本身就是做的**父子关系模型**

​	你想一下Java代码实现，他最底下的子类加载器，只能通过自己引用的父类加载器去找。如果直接找顶层类加载器，不合适的，那么顶层类加载器不就必须硬编码规定了吗？

​	这就是一个代码设计思想，保证代码的可扩展性。



ps: 为了防止源代码泄露，可以用工具对字节码加密。在类加载时，用**自定义的类加载器**来解密文件。

​    

#### 1.5 JVM 内存区域

```java
public class A {
    public static void main(String[] args) {
        B b = new B();
        b.load();
    }
}
```

```java
public class B {

      public void load(){
          boolean ifLoad = false;
      }
}
```



![image-20210311145810181](JVM.assets/image-20210311145810181.png)



内存区域流程:

​	结合上图, JVM启动，加载 A类到内存中，然后有一个main线程执行main方法，main线程关联一个**程序计数器**，记录执行到哪一行。其次，在main线程关联的**java虚拟机栈**里压入main方法的**栈桢**。main方法中需要创建B类的实例对象，这时把B类加载到内存中，创建B的对象实例分配在java**堆内存**中，并且在main()方法的栈桢中的局部变量表引入b变量，引用到B对象在堆内存中的地址。接着执行b.load 方法，创建栈桢，创建局部变量。执行完之后，把对应的方法出栈。



#### 1.6 垃圾回收

我们在java堆内存里创建的对象，都是占用内存资源的，而且内存资源有限。

如上面 b.load() 方法执行完之后，java堆内存的 B 对象实例没有变量引用它了，这时这可能就是一种浪费。



解决方法:  Jvm垃圾回收机制

本身是一个后台自动运行的线程，只要启动一个JVM进程，就会自带这么一个垃圾回收的后台线程。

这个线程会不断检查JVM堆内存中的各个实例对象。

如果某个实例的对象没有任何一个方法的局部变量,类的静态变量，包括常量等地方在指向他。那么垃圾回收线程就会把这个没人指向的 "B"实例对象回收，从内存里清除。 这些不被指向的对象实例就是Jvm的"垃圾"。



> **思考问题: 我们创建的对象，到底在java堆内存中占用多少内存？**



一个对象对内存的占用分两块

* 对象自己本身的一些信息
* 对象的实例变量作为数据占用的空间



在64位的linux操作系统上，对象头会占用 16 字节，如果实例对象内部有个int类型的实例变量，会占用4个字节，如果是long类型的实例变量会占用8个字节。如果是map，list就更多了。

jvm有许多优化的地方，如 补齐机制，指针压缩机制。较复杂，暂时不学。



>**既然堆内存的对象会被回收，那么方法区（永久代）的类会被垃圾回收吗？什么时候回收?为什么？**

   会,但是要满足下面的三个条件

* 首先，该类的所有实例对象都已经从 java 堆内存里被回收
* 其次，加载这个类的 ClassLoader 已经被收回
* 最后，对该类的 Class 对象没有任何引用   （Class 对象无法通过任何途径访问（包括反射）
  





#### 1.7 tomcat 相关问题



tomcat本身是java程序，那么tomcat的实现程序的class是由应用类加载器加载的，用户自己的java程序war包，放入tomcat的程序的classpath中这样用户的程序和tomcat的程序都是由应用类加载器加载了，也就是处于一个jvm中了





前言结束下面的学习会更细节。





#### 1.8 内存分代模型

​      根据对象生命相对的长短，JVM对对象进行了分代，年轻代、老年代、永久代。

  JVM将**Java堆内存**划分为了两个区域，一个是年轻代，一个是老年代。

* 年轻代，创建和使用完之后立马就要回收的对象存放的区域

* 老年代，创建之后需要一直长期存在的对象存放的区域。
* 永久代其实就是之前说的方法区，保存类相关信息



永久代类的回收满足下面三个条件就可以回收该类了

- 首先该类的所有实例对象都已经从Java堆内存里被回收；
- 其次加载这个类的ClassLoader已经被回收；
- 最后对该类的Class对象没有任何引用。



结合代码和图例进行理解

```java
public class A {
    private static C c = new C();
    public static void main(String[] args) throws InterruptedException {
        loadB();
        while(true){
           loadC();
           Thread.sleep(1000);
        }
    }

    public static void loadB(){
        B b =new B();
        b.loadFromDisk();

    }
    public static void loadC(){
        c.loadFromRemote();
    }
}
```



![image-20210312122743441](JVM.assets/image-20210312122743441.png)



大部分正常对象都是优先在新生代分配内存的，类静态变量c 引用的C对象实例是会长期存活在内存里的，但是一开始也

是分配在新生代里。

**那么什么情况下会触发新生代的回收?**

假设 loadB（）方法执行完毕，这个方法的栈桢出栈，导致没有变量引用B实例对象。

![image-20210312124818124](JVM.assets/image-20210312124818124.png)

会立即触发垃圾回收吗？

不会，垃圾回收需要触发条件的，假设现在创建了许多的对象。导致java堆内囤积了大量的对象，这个时候新生代预先分配的内存空间满了，他又需要在新生代分配一个新对象。这时候就触发了一次新生代的垃圾回收 "Minor GC" 也叫"Young GC"

这时候就会把大量没人引用的对象包括B回收掉。



![image-20210312125808731](JVM.assets/image-20210312125808731.png)



但是 “C对象”，会一直存活在新生代里，因为它一直被 A类的静态变量引用，不会被回收。

这时JVM规定，对象每垃圾回收一次，年龄就+1，所以当上图的 C对象在新生代成功躲过10多次垃圾回收，成为“老年人”就会被认为是会长期存活在内存里的对象，被转移到 java堆内存的老年代。



（后续）对象分配还有许多复杂机制:

*  新生代垃圾回收后，存活对象太多导致大量对象进入老年代
* 特别大的超大对象直接不经过新生代就进入老年代
* 动态对象年龄判断机制
* 空间担保机制



#### 1.9 Jvm核心参数



1. -Xms:  java堆内存大小         
2. -Xmx:  java堆内存最大大小
3. -Xmn:  java堆内存中新生代大小，扣除新生代剩下的就是老年代内存大小
4. -XX:PermSize         永久代大小             （jdk1.8后）-xx:MetaspaceSize
5. -XX:MaxPermSize   永久代最大大小         (jdk1.8后) -xx:MetaspaceSize
6. -Xss: 每个线程的栈内存大小

![image-20210312133304485](JVM.assets/image-20210312133304485.png)









### 2.百万流量订单系统预估

![image-20210312164527744](JVM.assets/image-20210312164527744.png)

现在一秒可能处理不了1000个订单了，因为压力骤增，系统性能下降，可能偶尔会出现某个请求处理完毕需要几秒甚至几十秒的时间，这时频繁触发gc回收机制，而一些请求处理的特别慢，就会进入老年代，老年代也越来越多，也会频繁触发老年代的垃圾回收，老年代的垃圾回收非常慢，极大影响系统性能。



永久代大小: 一般 几百MB够用。

栈内存大小: 一般默认 512KB~1Mb



### 3. 面试题



> **被哪些变量引用的对象是不能回收的？**



可达性分析算法: 每个对象都分析一下有谁在引用它，然后一层一层往上判断，看是否有一个**GC Roots**

局部变量，静态变量都可以看做是一种 GC roots。

总结:      对象被方法的局部变量,类的静态变量给引用，就不会回收。



> **java中对象不同的引用类型**

   参考链接:http://www.cnblogs.com/dolphin0520/p/3784171.html

* **强引用**   

  ​	如果内存不足，JVM会抛出OOM错误也不会回收object指向的对象。

  ​            （ B b = new B() ）  b 对 B 就是强引用 

  

* **软引用**   

   	软引用是用来描述一些有用但并不是必需的对象，只有在内存不足的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等

    SoftReference<String> sr = new SoftReference<String>( new String( "hello" )); 

​                      sr 对 String对象的引用就是软引用



* **弱引用**  

  ​	弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。

  WeakReference<String> sr = newWeakReference<String>(newString("hello"));

* **虚引用** （PhantomReference） 

  ​	基本不用。

  ​	它并不影响对象的生命周期，如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。

  ​	要注意的是，虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。



> **如何利用软引用和弱引用解决OOM问题?**

​		假如有一个应用需要读取大量的本地图片，如果每次读取图片都从硬盘读取，则会严重影响性能，但是如果全部加载到内存当中，又有可能造成内存溢出，此时使用软引用可以解决这个问题。

　　设计思路是：用一个HashMap来保存图片的路径 和 相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。在Android开发中对于大量图片下载会经常用到。










今日分享： 线上机器CPU负载过高如何去排查？如何优化JVM参数？

（1）第一可以通过 top -Hp PID , jstack PID等查看占用CPU资源过高的线程是哪些？可能会看到是GC线程。
或者是其他线程，如果是GC线程，那么jstat查看JVM垃圾回收器工作的情况。如果是其他业务线程，可能需要跟踪栈信息，追踪到代码中进行分析。（可能是一直循环处理业务，数据量大，处理耗时。）
-- 业务线程导致CPU高的场景，没有关注过，不知道我的理解对不对。
（2）查看JVM垃圾回收情况相关的信息
YoungGC频率，YoungGC耗时，每次GC过后Eden+S0区的垃圾回收情况；进入老年代的大小
FullGC频率，YoungGC耗时，每次GC过后老年代的垃圾回收情况；
我的总结：
（1）如果是YoungGC，FullGC频繁，但是每次FullGC回收之后，垃圾回收率很高，可能就是高并发引起的；要关注下是不是年轻代内存分配不合理，是否需要加大JVM堆内存。升级机器等。根据YoungGC每次进入老年代的大小，重新预估一下，新生代需要分配多大的内存比较合适，来解决这个高并发引起的FullGC问题。
（2）如果FullGC之后，回收的内存时多时少，或者说很少，甚至可能出现连续的1-3次，回收之后，老年代剩余空间是在增长的，这个时候就要排除是否有发生内存泄漏的嫌疑。或者说高并发引起的问题导致对象无法被回收。这时候一般需要dump下内存快照，使用MAT工具分析内存快照，可以短时间连续dump两次，对比两次内存快照，查看哪些对象不断在增长。这些对象是不是大对象，因为并发问题无法被及时回收，JVM处在OOM边缘。然后根据派排查结果，优化代码问题。
优化JVM参数：
（1）优化新生代和老年代的占比。尽量保证每次YoungGC之后。可以打印对内存信息，计算一下一般存活对象是多大。假设是100M。那么可以将S0设置成 S0 * 50% = 100M。 S0大概需要200M。这样就可以把Eden和老年代大小预估出来了，一般业务系统。老年代分配1至2G就可以了。
（2）需要开启CMS垃圾回收器的对内存碎片进行整理。一般每次FullGC都整理一遍最好。
（3）-XX:CMSInitiatingOccupancyFraction=92。老年代占用92%以上发生FullGC。一般这个值我觉得偏大了，如果是高并发系统，会有较大可能出现Concurrent Mode Failure。所以我对CMS设置的时候，会把老年代预留空间大小预估到S0区大小这样。一般设置80%。对于这点不知道是否合理？
（4）还会设置一些额外的参数：-XX:-OmitStackTraceInFastThrow
还有打印GC日志，发生OOM的时候dump内存快照参数。
（5）还有一点，如果没有发生什么特殊的问题，不会对其他的参数进行优化。能简单设置就采用简单的设置。











下次分享 ：你说你精通jvm调优，能够说下G1工作原理以及整体流程吗？