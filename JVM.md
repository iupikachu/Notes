





## JVM



### 1.前言

#### 1. 1 java代码如何运行?

![image-20210309163548308](JVM.assets/image-20210309163548308.png)

.java              .class              01100101  

 java代码    -》  java 字节码 -》机器码

​                打包                 JVM 

#### 1.2 类加载到使用过程 （.class 字节码文件加载到 JVM内存中）



> **加载    验证   准备  解析  初始化 使用 卸载**

  实用角度简单解析

* 验证  .class 文件内容是否符合JVM规范
* 准备   类变量(static 修饰的变量)分配内存空间 赋默认的初始值
* 解析   (很复杂,符号引用替换为实际引用)
* 初始化 （核心阶段） 执行类的初始化代码块（static代码块）



**什么时候初始化一个类?**

1. new 实例化对象时，触发类的加载到初始化的全过程
2. 包含main方法的主类，必须立马初始化好
3. 初始化类时，他的父类没有初始化，就必须先初始化他的父类



#### 1.3  什么情况会加载一个类?

1. 类有main方法作为程序主入口

2. 代码执行用到某个类的时候

   



#### 1.4  类加载器和双亲委派机制



**1.启动类加载器**

BootStrap ClassLoader  加载java目录下的核心类 （java安装目录下的"lib"目录）java最核心的类库，支撑java系统运行

一旦jvm启动，首先就会依托启动类加载器。



**2.扩展类加载器**

Extension ClassLoader  java安装目录下有 "lib/ext"目录，就是用它来加载，支撑系统运行。



**3.应用程序类加载器**

Application ClassLoader 复制加载 "ClassPath" 环境变量所指定的路径的类 （大致理解为加载自己写好的Java代码）



**4.自定义类加载器**

根据自己的需求加载



![image-20210309162656294](JVM.assets/image-20210309162656294.png)



![image-20210309162801953](JVM.assets/image-20210309162801953.png)

​		

**双亲委派流程:**

​	当一个Hello.class这样的文件要被加载时。不考虑我们自定义类加载器，首先会在AppClassLoader中检查是否加载过，如果有那就无需再加载了。如果没有，那么会拿到父加载器，然后调用父加载器的loadClass方法。父类中同理也会先检查自己是否已经加载过，如果没有再往上。注意这个类似递归的过程，直到到达Bootstrap classLoader之前，都是在检查是否加载过，并不会选择自己去加载。直到BootstrapClassLoader，已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛出ClassNotFoundException。

**双亲委派模式优势**

**避免重复加载 + 避免核心类篡改**
	采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心JavaAPI发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。



>**为什么必须要一级一级类加载器的往上找，直接从顶层类加载器开始找不就行了吗？**

​	其实关于这个问题，不用过于纠结，每一层类加载器对某个类的加载，上推给父类加载器，到顶层类加载器，如果发现自己加载不到，再下推回子类加载器来加载，这样可以保证绝对不会重复加载某个类。至于为什么不直接从顶层类加载器开始找，那是因为类加载器本身就是做的**父子关系模型**

​	你想一下Java代码实现，他最底下的子类加载器，只能通过自己引用的父类加载器去找。如果直接找顶层类加载器，不合适的，那么顶层类加载器不就必须硬编码规定了吗？

​	这就是一个代码设计思想，保证代码的可扩展性。



ps: 为了防止源代码泄露，可以用工具对字节码加密。在类加载时，用**自定义的类加载器**来解密文件。

​    

#### 1.5 JVM 内存区域

```java
public class A {
    public static void main(String[] args) {
        B b = new B();
        b.load();
    }
}
```

```java
public class B {

      public void load(){
          boolean ifLoad = false;
      }
}
```



![image-20210311145810181](JVM.assets/image-20210311145810181.png)



内存区域流程:

​	结合上图, JVM启动，加载 A类到内存中，然后有一个main线程执行main方法，main线程关联一个**程序计数器**，记录执行到哪一行。其次，在main线程关联的**java虚拟机栈**里压入main方法的**栈桢**。main方法中需要创建B类的实例对象，这时把B类加载到内存中，创建B的对象实例分配在java**堆内存**中，并且在main()方法的栈桢中的局部变量表引入b变量，引用到B对象在堆内存中的地址。接着执行b.load 方法，创建栈桢，创建局部变量。执行完之后，把对应的方法出栈。



#### 1.6 垃圾回收

我们在java堆内存里创建的对象，都是占用内存资源的，而且内存资源有限。

如上面 b.load() 方法执行完之后，java堆内存的 B 对象实例没有变量引用它了，这时这可能就是一种浪费。



解决方法:  Jvm垃圾回收机制

本身是一个后台自动运行的线程，只要启动一个JVM进程，就会自带这么一个垃圾回收的后台线程。

这个线程会不断检查JVM堆内存中的各个实例对象。

如果某个实例的对象没有任何一个方法的局部变量,类的静态变量，包括常量等地方在指向他。那么垃圾回收线程就会把这个没人指向的 "B"实例对象回收，从内存里清除。 这些不被指向的对象实例就是Jvm的"垃圾"。



> **思考问题: 我们创建的对象，到底在java堆内存中占用多少内存？**



一个对象对内存的占用分两块

* 对象自己本身的一些信息
* 对象的实例变量作为数据占用的空间



在64位的linux操作系统上，对象头会占用 16 字节，如果实例对象内部有个int类型的实例变量，会占用4个字节，如果是long类型的实例变量会占用8个字节。如果是map，list就更多了。

jvm有许多优化的地方，如 补齐机制，指针压缩机制。较复杂，暂时不学。



>**既然堆内存的对象会被回收，那么方法区（永久代）的类会被垃圾回收吗？什么时候回收?为什么？**

   会,但是要满足下面的三个条件

* 首先，该类的所有实例对象都已经从 java 堆内存里被回收
* 其次，加载这个类的 ClassLoader 已经被收回
* 最后，对该类的 Class 对象没有任何引用   （Class 对象无法通过任何途径访问（包括反射）
  





#### 1.7 tomcat 相关问题



tomcat本身是java程序，那么tomcat的实现程序的class是由应用类加载器加载的，用户自己的java程序war包，放入tomcat的程序的classpath中这样用户的程序和tomcat的程序都是由应用类加载器加载了，也就是处于一个jvm中了





前言结束下面的学习会更细节。





#### 1.8 内存分代模型

​      根据对象生命相对的长短，JVM对对象进行了分代，年轻代、老年代、永久代。

  JVM将**Java堆内存**划分为了两个区域，一个是年轻代，一个是老年代。

* 年轻代，创建和使用完之后立马就要回收的对象存放的区域

* 老年代，创建之后需要一直长期存在的对象存放的区域。
* 永久代其实就是之前说的方法区，保存类相关信息



永久代类的回收满足下面三个条件就可以回收该类了

- 首先该类的所有实例对象都已经从Java堆内存里被回收；
- 其次加载这个类的ClassLoader已经被回收；
- 最后对该类的Class对象没有任何引用。



结合代码和图例进行理解

```java
public class A {
    private static C c = new C();
    public static void main(String[] args) throws InterruptedException {
        loadB();
        while(true){
           loadC();
           Thread.sleep(1000);
        }
    }

    public static void loadB(){
        B b =new B();
        b.loadFromDisk();

    }
    public static void loadC(){
        c.loadFromRemote();
    }
}
```



![image-20210312122743441](JVM.assets/image-20210312122743441.png)



大部分正常对象都是优先在新生代分配内存的，类静态变量c 引用的C对象实例是会长期存活在内存里的，但是一开始也

是分配在新生代里。

**那么什么情况下会触发新生代的回收?**

假设 loadB（）方法执行完毕，这个方法的栈桢出栈，导致没有变量引用B实例对象。

![image-20210312124818124](JVM.assets/image-20210312124818124.png)

会立即触发垃圾回收吗？

不会，垃圾回收需要触发条件的，假设现在创建了许多的对象。导致java堆内囤积了大量的对象，这个时候新生代预先分配的内存空间满了，他又需要在新生代分配一个新对象。这时候就触发了一次新生代的垃圾回收 "Minor GC" 也叫"Young GC"

这时候就会把大量没人引用的对象包括B回收掉。



![image-20210312125808731](JVM.assets/image-20210312125808731.png)



但是 “C对象”，会一直存活在新生代里，因为它一直被 A类的静态变量引用，不会被回收。

这时JVM规定，对象每垃圾回收一次，年龄就+1，所以当上图的 C对象在新生代成功躲过10多次垃圾回收，成为“老年人”就会被认为是会长期存活在内存里的对象，被转移到 java堆内存的老年代。



（后续）对象分配还有许多复杂机制:

*  新生代垃圾回收后，存活对象太多导致大量对象进入老年代
* 特别大的超大对象直接不经过新生代就进入老年代
* 动态对象年龄判断机制
* 空间担保机制



#### 1.9 Jvm核心参数

一般来说，对于线上部署系统启动的时候，有多种方式设置Jvm参数。

Idea中设置 Debug JVM Arguments

java -jar 命令启动时直接在后面跟上jvm参数

部署到Tomcat时可以在Tomcat的catalina.sh中设置Tomcat的Jvm参数，使用Springboot也可以在启动时指定Jvm参数。





1. -Xms:  java堆内存大小         
2. -Xmx:  java堆内存最大大小
3. -Xmn:  java堆内存中新生代大小，扣除新生代剩下的就是老年代内存大小
4. -XX:PermSize         永久代大小             （jdk1.8后）-xx:MetaspaceSize
5. -XX:MaxPermSize   永久代最大大小         (jdk1.8后) -xx:MetaspaceSize
6. -Xss: 每个线程的栈内存大小

![image-20210312133304485](JVM.assets/image-20210312133304485.png)



-XX:NewSize=5242880 -XX:MaxNewSize=5242880 -XX:InitialHeapSize=10485760 -XX:MaxHeapSize=10485760 -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=10485760 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log





### 2.百万流量订单系统预估

![image-20210312164527744](JVM.assets/image-20210312164527744.png)

​	现在一秒可能处理不了1000个订单了，因为压力骤增，系统性能下降，可能偶尔会出现某个请求处理完毕需要几秒甚至几十秒的时间，这时频繁触发gc回收机制，而一些请求处理的特别慢，就会进入老年代，老年代也越来越多，也会频繁触发老年代的垃圾回收，老年代的垃圾回收非常慢，极大影响系统性能。



永久代大小: 一般 几百MB够用。

栈内存大小: 一般默认 512KB~1Mb



### 3. 垃圾回收





> **被哪些变量引用的对象是不能回收的？**



可达性分析算法: 每个对象都分析一下有谁在引用它，然后一层一层往上判断，看是否有一个**GC Roots**

方法的局部变量，类的静态变量都可以看做是一种 GC roots。

总结:      对象被**方法的局部变量**,**类的静态变量**给引用，就不会回收。



> **java中对象不同的引用类型**

   参考链接:http://www.cnblogs.com/dolphin0520/p/3784171.html

* **强引用**   

  ​	如果内存不足，JVM会抛出OOM错误也不会回收object指向的对象。

  ​            （ B b = new B() ）  b 对 B 就是强引用 

  

* **软引用**  **(内存不足回收)**

   软引用是用来描述一些有用但并不是必需的对象，只有在内存不足的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等

    SoftReference<String> sr = new SoftReference<String>( new String( "hello" )); 

​                      sr 对 String对象的引用就是软引用



* **弱引用**  **（都会被回收）**

  ​	弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。

  WeakReference<String> sr = newWeakReference<String>(newString("hello"));

* **虚引用** （PhantomReference） 

  ​	基本不用。

  ​	它并不影响对象的生命周期，如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。

  ​	要注意的是，虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。



> **如何利用软引用和弱引用解决OOM问题?**

​		假如有一个应用需要读取大量的本地图片，如果每次读取图片都从硬盘读取，则会严重影响性能，但是如果全部加载到内存当中，又有可能造成内存溢出，此时使用软引用可以解决这个问题。

　　设计思路是：用一个HashMap来保存图片的路径 和 相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。在Android开发中对于大量图片下载会经常用到。



> **finalize()方法的作用**



没有Gc roots 引用的对象可以回收，有 GC Roots 的对象不能回收，如果有 Gc roots 引用，但是如果是软引用或者弱引用也有可能被回收掉。

**假设没有Gc roots引用的对象是一定立马被回收吗？**

finalize（）方法可以拯救。

加入某个对象要被垃圾回收了，但是这个对象重写了Object类中的 finalize()方法并且这个方法中把自己给某个Gc roots变量。

![image-20210312205307246](JVM.assets/image-20210312205307246.png)

重新让instance这个 gc roots 变量引用了自己。就不用被垃圾回收了。



#### 3.1 新生代的垃圾回收算法

  

##### 3.1.1**复制算法**:   **Eden区和Survivor区**



![image-20210313114504935](JVM.assets/image-20210313114504935.png)



一个 Eden区，两个survivor区，eden区占80%内存空间，每一块survivor区占 10%。

平时使用一块eden和一块survivor区所以内存使用率为 90%。

​	刚开始对象都分配在eden区，如果eden区快满了就触发垃圾回收，把eden区中的存活对象转移到一块空着的survivor区，eden区清空，然后再次分配新对象到eden区，再触发垃圾回收，就把eden区存活的和survivor区存活的转移到另一块空着的survivor。



**这么设计的原因**: 每次垃圾回收可能存活下来的对象就1%,如果eden+一块survivor满了900MB，一次垃圾回收下来有10MB存活，就把10MB转移到另一块survivor区。始终保持一块survivor区是空着的。这样可以控制内存碎片，而且内存的使用率都很高。



**遗留问题**:

* 万一存活下来的对象超过10%内存空间，在另外一块survivor区放不下怎么办？
* 万一突然分配超级大的对象，大到新生代找不到连续的空间来存放，怎么办？
* 到底一个存活对象要在新生代来回倒腾多少次才会去老年代？



**解答**

比如 static B b = new B(); 

静态变量b会一直引用B对象，这类对象不会被回收掉，每在新生代里躲过一次gc被转移到一块Survivor区时，年龄就长一岁。

默认的设置是达到15岁时转移到老年代。

也可以通过jvm参数（年龄阈值）"-XX:MaxTenuringThreshold"设置



##### 3.1.2**动态对象年龄判断**

有另一个规则可以让对象早点进入老年代：**动态对象年龄判断**

触发时机：发生Minor Gc 后，将存活的对象移动到空闲的 Survivor区时触发





![image-20210313123221676](JVM.assets/image-20210313123221676.png)



图里一岁和二岁的对象加起来>=survivor区的一半50MB ，那么survivor2区里年龄大于等于2岁的对象要提前进入老年代。



##### 3.1.3**大对象直接进入老年代**

有一个jvm参数  "-XX：PretenureSizeThreshold "可以把他的值设为字节数。比如 1048576字节，就是1MB 

如果你创建了一个大于这个大小的对象，比如一个超级大的数组，就直接把这个大对象放到老年代里。不会经过新生代。

之所以这么做，就是要避免新生代出现大对象，然后屡次躲过GC,还要把他在两个Survivor区域里来回复制多次之后才进入老年代。



##### 3.1.4 **空间分配担保机制**

survivor区内存比较小，所以尽可能保证在一次Minor gc后，如果survivor区放不下，老年代要放得下，所以在Minor gc前要先计算老年代的可用空间够不够，能不能兜底。

**抛几个问题：**

**1.什么是空间分配担保？**

　　　　在发生**Minor GC**之前，虚拟机会检查**老年代最大可用的连续空间**是否**大于新生代所有对象的总空间**，

　　　　如果大于，则此次**Minor GC是安全的**

　　　　如果小于，则虚拟机会查看**HandlePromotionFailure**设置值是否允许担保失败。如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于**历次晋升到老年代的对象的平均大小**，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。

**2.为什么要进行空间担保？**

　　　　是因为新生代采用**复制收集算法**，假如大量对象在Minor GC后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而Survivor空间是比较小的，这时就需要老年代进行分配担保，把Survivor无法容纳的对象放到老年代。**老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象**，但一共有多少对象在内存回收后存活下来是不可预知的，**因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考**。使用这个平均值与老年代剩余空间进行比较，来决定是否进行Full GC来让老年代腾出更多空间。







**问题：Minor Gc后的对象太多无法放入Survivor区怎么办?**

假如在发生gc的时候，eden区里有150MB对象存活，而Survivor区只有100MB，无法全部放入，这时就必须把这些**对象全部直接转移到老年代**里。



**问题: 接着上面的问题，如果这时老年代的可用内存小于新生代全部对象大小，万一Minor gc后新生代的对象都存活下来，然后需要全部转移到老年代，但是老年代空间不够，怎么办？**

理论上有这个可能。

这时如果设置了 "-XX:-HandlePromotionFailure"的参数，就会尝试判断，看老年代内存大小是否大于之前每一次Minor gc后进入老年代的对象的平均大小。

比如说，之前Minor gc 平均10M左右的对象进入老年代，此时老年代可用内存大于10MB,那么大概率老年代空间是足够的。

如果上面那个判断失败，或者是根本没设置这个参数，那就直接触发"Full GC"，对老年代进行垃圾回收，腾出些空间，再Minor gc。



如果判断成功了，那么大概率老年代内存是够的，就冒风险尝试Minor gc。这时有以下几种可能。

* Minor Gc 后，剩余的存活对象大小，小于Survivor区，那就直接进入Survivor区。
* MInor Gc 后，剩余的存活对象大小，大于Survivor区，小于老年代可用内存，那就直接去老年代。
* Minor Gc后，大于Survivor，老年代，很不幸，就会发生"Handle Promotion Failure"的情况 ，触发"Full GC"。



**Full gc** 就是对老年代进行垃圾回收，同时也一般会对新生代进行垃圾回收。

如果 Full gc后老年代还是没有足够的空间存放剩余的存活对象，那么就会导致**"OOM"** out of memory 内存溢出。



**所以Minor gc 触发要先对老年代空间做检查看看老年代空间够不够。**检查失败的时候触发"Full Gc"给老年代腾空间，或者Minor gc 后剩余对象太多放入老年代内存都不敢，也要触发"Full Gc"。



总结：触发老年代垃圾回收（Full gc) 的时机

* Minor gc 前，检查一下发现之前的   Avg（进入老年代对象的大小）> 现在老年代可用空间，提前触发Full gc。
* Minor gc 后，发现剩余对象 > 老年代可用空间，触发Full gc。



一张图总结一下

![image-20210314124016461](JVM.assets/image-20210314124016461.png)



根据上图回答问题

1. 什么时候会触发Minor gc?

2. 触发Minor gc 之前会如何检查老年代的大小，涉及哪几个步骤和条件？

3. 什么时候在Minor Gc 之前就会提前触发一次 Full gc?

   1. .......

   2. .......

   3. .......

   4. 老年代已用内存空间超过 "-XX: CMSInitiatingOccupancyFaction" 参数指定的比例，自动触发Full gc

      

4. Minor gc 过后可能对应那几种情况?



Minor gc 存活对象总大小 = M.memory      Survivor区可用空间 = S.memory  老年代可用连续空间 = O.memory

* M.memory < S.memory                        M.memory 迁移至 Survivor区后触发（大龄对象判定，动态年龄判定）视情况移入老年代，如果老年代可用连续空间不够，先 Full gc 再 Minor Gc 还不够，报OOM。
* S.memory < M.memory < O.memory     存活对象直接迁移至老年代中
* O.memory < M.memory                        先Full gc 再Minor gc ，老年代空间还是不够，报OOM。



5.哪些情况下Minor gc 的对象会进入老年代?



**Stop the World** 问题

JVM最让人无奈的痛点: 在垃圾回收时，jvm发送 “stop the world” 让java后台程序停止运行以免产生新对象，专心垃圾回收。

#### 3.2 年轻代垃圾回收器



**ParNew (多线程)**

-XX:+UseParNewGC  指定使用parnew

默认情况下 ParNew线程数量和cpu的核数一样

可以通过 -XX:ParallelGCThreads 设置线程数量



**Serial (单线程)**



> 什么时候用parnew ？什么时候用 Serial ?

启动系统的时候可以区分客户端模式和服务器端模式。

系统如果部署在服务器上，就应该用服务器模式，如果你的系统是运行在比如Windows上的客户端程序，就应该是客户端模式。

部署在服务器上的话，应该使用Parnew，因为多线程并行垃圾回收，充分利用多核CPU资源。提升性能

是客户端程序的话，很多都是单核cpu，此时如果还要用 ParNew来回收的话，就会导致一个cpu运行多个线程，反而加重了性能开销，因为单cpu运行多线程会导致频繁的上下文切换。

#### 3.3 **老年代垃圾回收的算法**



标记清理算法: 先把老年代中存活的对象打标记，然后把标记的存活对象挪到一边，然后再清空非存活对象的那一边。

先通过追踪 GC Roots 的方法，看看各个对象是否被Gc Roots给引用了，如果是的话，就是存活对象，否则就是垃圾对象。将垃圾对象标记出来，然后一次性回收掉。

#### 3.4 老年代垃圾回收器



CMS 采用标记清理算法

CMS 采取 **垃圾回收线程和系统工作线程尽量同时执行的模式来处理**

如何实现？

* 初始标记

  这个阶段，系统的工作线程全部停止，进入"stop the world",标记出所有的Gc roots对象。虽然要 stw,但是影响不大，因为速度非常快。

* 并发标记 （Gc roots 深度追踪）

  系统线程可以随意创建各种新对象，继续运行，这个阶段可能会创建新的存活对象，也可能部分存活对象失去引用。在这个过程中，垃圾回收线程会尽可能的对已有的对象进行 GC Roots追踪。

  简而言之，会对老年代所有对象进行GC Roots 追踪，是最耗时的。被方法区静态变量引用的类其中的实例变量引用的类这一阶段会被标记存活。

* 重新标记

  因为第二阶段结束，会多出许多之前没标记的存活对象和垃圾对象，所以再次进入"stop the world",然后重新标记在第二阶段新创建的一些对象和失去引用变成垃圾的对象。这个阶段速度很快。

* 并发清理

  系统恢复运行，然后清理之前标记的垃圾对象。很耗时，但是是和程序并发运行，所以不影响系统的运行。

![image-20210315105540039](JVM.assets/image-20210315105540039.png)



​	简单来说，为了避免长时间的"Stop the World" ,CMS采用了4个阶段来垃圾回收，其中初始标记和重新标记，耗时短，虽然会导致stw，但是影响不大，然后并发标记和并发清理，两个耗时最长，但是可以跟系统的工作线程并发运行，所以对系统影响不大。

这就是CMS的基本工作原理。



**CMS 的弊端：**

* **消耗cpu资源**
* **Concurrent Mode Failure (并发模式失败)**

​        并发清理的时候，系统一直在运行，可能会随着系统的运行让一些对象进入老年代，变成垃圾对象。这种垃圾对象----浮动垃圾。需要等到下一次 Full Gc清理他们。所以为了保证在CMS垃圾回收期间还有一定的空间让一些对象进入老年代，一般会预留一些空间。

​		  "-XX：CMSInitiatingOccupancyFaction" 参数设置老年代占用多少比例时触发CMS垃圾回收。

​			jdk1.6 默认是 92%

如果在这期间，进入老年代的对象大于可用内存空间，那么会触发 Concurrent Mode Failure，并发垃圾回收失败。这时会自动用"Serial Old" 垃圾回收器替代CMS。就是直接把系统"Stop the World" 重新进行长时间的Gc Roots追踪，标记出全部垃圾对象，不允许新的对象。然后一次性回收，再恢复系统。

* **内存碎片**

老年代CMS 采用标记清理算法，标记垃圾，回收，会产生大量的内存碎片。太多的内存碎片会导致频繁的Gc。

​			"-XX：+UseCMSCompactAtFullCollection" 参数默认打开。

​			表示在 Full Gc后要再次进行"Stop the world" 停止工作线程，再进行碎片整理，把存活的对象挪到一边，空出大片连续的内存空间。

​			"-XX：CMSFullGCsBeforeCompaction" 

​			执行多少次 Full Gc 之后再执行内存碎片整理工作。默认是 0，每次都需要。

> 为什么老年代的 Full GC 比新生代的 Minor GC 慢很多倍？一般在10倍以上？

**ParNew的Minor GC**

​    新生代一般存活对象少，采用复制算法，从Gc root出发标记存活对象，直接把存活对象复制到另一块内存，其余直接清除。

​	新生代执行速度快，因为直接从 Gc Roots 出发，追踪哪些对象是存活的就行，新生代存活的对象是很少的。然后直接放入Survivor,就一次性回收eden区和之前的Survivor区。



**CMS的Full GC**

   老年代，对象存活量大，每次遍历堆分别去标记存活对象和垃圾对象，再遍历把垃圾对象清除，最后还要一定存活对象，防止太多内存碎片。

* ​	在并发标记阶段，需要去深度追踪所有的存活对象，老年代存活对象很多。
* ​    并发清理阶段，也不是一次性回收一大片内存，而是找到零零散散在各个地方的垃圾对象。
* ​    最后还要执行内存碎片整理，把存活对象移一起，空出连续空间，这个过程还得 "Stop the world"
*  并发清理期间，剩余空间不足存放新进的对象时，还会触发"Concureent Mode Failure"，更加麻烦，还要使用"Serial Old"单线程的垃圾回收器，"Stop the world"后再重新来一遍回收过程。更加耗时。



#### 3.5 最新的 G1 垃圾回收器



**Parnew + CMS 的痛点**: 无论是新生代还是老年代的垃圾回收，都会或多或少产生"stop the world" ，对系统运行有一定影响。而且不是可控的，只能优化。



##### 3.5.1 G1垃圾回收器概述



G1 垃圾回收器可以同时回收新生代和老年代的对象，一个人负责所有。

**内存结构**: 把java堆内存拆分为多个大小相等的Regin,新生代可能包含了某些块，老年代可能包含某些块。

![image-20210317134821726](JVM.assets/image-20210317134821726.png)



**特点: 可以设置垃圾回收的预期停顿时间**

比如我们可以指定G1 在垃圾回收时候可以保证，在一小时内垃圾回收导致的"stop the world"时间不超过一分钟。



**实现原理**: 追踪每个 Region里的**回收价值** （耗费时间，垃圾对象大小）

![image-20210317135333475](JVM.assets/image-20210317135333475.png)



假设 G1通过追踪发现，1个Region中的垃圾对象由10m，回收需要1s，另一个垃圾对象20m，回收需要200ms。下一次执行垃圾回收时，回收掉上图中只需要200ms就能回收200mb垃圾的Region。



**核心设计思路:** 简单来说，G1可以做到让你来设定垃圾回收对系统的影响，通过把内存拆分为大量小Region,追踪每个Region可以回收对象的大小和预估时间，最后在垃圾回收的时候，尽量把垃圾回收对系统造成的影响控制在指定的时间范围内。有限时间内回收尽可能多的对象。





##### 3.5.2 设定内存大小



用 "-Xm" 和 "-Xmx" 设置堆内存的大小。

"-XX：+UseG1GC" 指定使用G1 垃圾回收器。

Jvm自动用堆大小除以2048

Jvm最多可以有 2048个Region ,Region的大小必须是2的倍数。比如1MB、2MB、4MB

比如堆大小是 4G=4096MB 除以 2048  那么每个Region大小是2MB。

一般保持这种默认的计算方式。如果通过手动方式指定: "-XX:G1HeapRegionSize"



刚开始的时候，默认新生代对堆内存的占比是5%,也就是200MB左右的内存，大概100个Region。

可以通过 "**-XX：G1NewSizePercent**" 设置新生代初始占比。

在系统运行中，Jvm会不停地给新生代增加更多的Region,但是最多新生代的占比不会超过 60%。

可以通过 "**-XX：G1MaxNewSizePercent**"改变。



新生代还是有 Eden 和 Survivor 划分的。

"-XX：SurvivorRation=8"，区分eden和 survivor比例。

比如新生代一开始有100个 Region，那么80个Region是eden,两个Survivor各占10个。



##### 3.5.3 新生代垃圾回收

既然新生代也有 eden 和 survivor ，那么触发垃圾回收的机制都是类似的。

Jvm不断的给新生代加入更多的Region,直到新生代占据堆大小的最大比例 60%。

新生代大概占据1000个region了，还占满了对象，每个Survivor是100个大小。

这时候触发 新生代的Gc，G1就用之前的复制算法进行垃圾回收，进入"stop the world"。

eden中的存活对象放入 S1 的region中，接着回收掉eden中的对象。但是这个过程是有区别的，因为G1可以设定目标停顿时间。最多系统停顿时间。可以通过 "**-XX：MaxGCPauseMills**" 设定。默认值是 200ms。**是每次" stop the world " 的停顿时间。**

G1 就会通过之前说的，追踪每个Region回收时间，垃圾对象大小，保证Gc 停顿时间控制在指定范围内，尽可能多的回收一些对象。



##### 3.5.4 老年代垃圾回收



老年代最多占据 40%的 Region,大概就是800个左右的Region。



**对象进入老年代的条件**

和之前几乎一模一样。

* 躲过多次垃圾回收，达到一定年龄。

"**-XX：MaxTenuringThreshold**" 设置年龄，进入老年代。

* 动态年龄判断规则,某次Gc后，存活对象超过Survivor区的50%。

​       此时会判断，比如1岁、2岁、3岁、4岁以上的对象大小综合超过了Survivor区的50%，此时4岁以上的对象会全部进入老年代，这就是动态年龄判断规则。





##### 3.5.5大对象回收分配策略

大对象不属于新生代和老年代，在G1里，新生代和老年代是动态的，不断变化的。比如一次垃圾回收后，eden里面的1000个region都空了，就可以让一些region存放大对象。

新、老年代在回收的时候，会顺带带着大对象Region一起回收。



![image-20210317145521505](JVM.assets/image-20210317145521505.png)



##### 3.5.6 混合垃圾回收 (Mixed-GC)



**条件:**

G1 有一个参数（**IHOP**） "**-XX：InitiatingHeapoccupancyPercent **" 默认值 45%

如果**老年代占据了堆内存的 45%的Region**,此时就会触发 新生代+老年代+大对象 一起回收的混合回收。



**过程:**

* **初始标记**：进入"stop the world" ,就只标记Gc roots 直接引用的对象(线程栈内存中的局部变量，方法区中的类静态变量)。速度很快。
* **并发标记**：允许系统程序的运行，同时进行"GC Roots"追踪，追踪所有存活对象(间接引用的对象)。很耗时，要追踪全部的存活对象。但是是并发运行，对系统影响不大。Jvm还会对这个阶段，一些对象的修改记录起来，比如对象新建，对象失去引用。
* **最终标记**：进入"stop the world" ，根据并发标记记录的对象修改，最终标记存活对象，垃圾对象。
* **混合回收**：计算老年代中每个Region的存活对象数量，存活对象占比，执行垃圾回收的预期性能和效率。然后停止系统运行，全力以赴进行垃圾回收，为了控制垃圾回收时间在指定的范围，会对部分的region进行回收。
* Mixed GC过程中会将多个老年代Region中仍存活的小对象集中到一个Region中，也就是说**Mixed GC会对老年代空间进行内存整理**



ps: 在最后一个阶段"**混合回收**"的时候，会停止程序运行，但是为了不让程序过长时间停止，可以多次执行"混合回收"。

​	比如说，要回收100个Region先停止工作，执行一次混合回收，回收掉30个Region，接着恢复系统运行，然后再停止系统运行，再执行一次混合回收，回收掉30个。以此往复。有一个参数可以控制这个次数。

​	"**-XX：G1MixedGCCountTarget** "    默认值为8。

​	  在一次混合回收中，最后一个阶段执行几次。

   " **-XX：G1HeapWastePercent**  "       默认值5% 。

​		也就是在全局标记结束后能够统计出所有Cset内可被回收的垃圾占整对的比例值，如果超过5%，那么就会触发之后的多轮Mixed GC，如果不超过，那么会在之后的某次Young GC中重新执行全局并发标记。可以尝试适当的调高此阈值，能够适当的降低Mixed GC的频率。

​		空闲的Region数量达到老年代堆内存的5%就会停止回收，比如正常是8次回收，但是到第4次，空闲Region达到5%了，就不进行后续的混合回收了。

​    ''**-XX:  G1MixedGCLiveThresholdPercnt**"    默认值 85% 。

​		存活对象低于85%的 Region才可以进行回收。

​       如果一个对象存活对象多余85%，要把这些对象拷贝到别的Region，成本很高。





**Mixed-Gc回收失败:**

​	因为回收时，无论老年代还是年轻代执行复制算法，都要把存活对象拷贝到别的Region中，万一没有空闲的Region可以放存活对象了。就会失败。

​	一旦失败，立马切换为单线程垃圾回收，停止系统程序，进行标记、清理、整理。空闲出来一批Region。过程很慢。



##### 3.5.7 总结



当新生代Region大于 60 %进行新生代垃圾回收时，如果200ms回收后的Region是小于 survivor区的大小的话就不需要进入老年代了。

当老年代 Region大于 45%的时候才会去触发 mixed gc。



![image-20210318101504645](JVM.assets/image-20210318101504645.png)



**为什么要选择 G1 垃圾处理器?**

* G1在停顿时间上添加了预测机制，用户可以设置期望停顿时间，Stop The World时间相对可控。
* G1的年轻代和老年代空间并不是固定的，当现有年轻代分区占满时，JVM会分配新的空闲Region加入到年轻代空间，老年代也是如此。还记得在CMS中出现的年轻代空间有大量浪费的情况吗？那将不再是问题。另一方面，由于无法保证每台机器的吞吐完全一致，不同机器的GC压力也是不一样的，该特性使得系统进程可以根据情况自行调整年轻代和老年代的空间大小，以应对不同的GC压力
* G1 GC的回收过程中有内存整理，理论上不会产生内存碎片！

* G1 很适合大内存的机器，因为如果是 ParNew+CMS，每次Gc都是内存快满了，此时一下子要回收对象太多，导致gc停顿时间太长。针对大内存机器，G1很适合。





**如何尽量减少Mixed Gc 频率?**

Mixed gc 触发条件是老年代到达 IHOP 设置的值。

* 让垃圾对象尽可能在新生代就被回收掉，让短命对象不进入老年代，这就要求根据具体应用系统来合理设置新生代Eden大小和Survivor的大小。
* 将新生代分配更大空间，老年代设置为较小值。但是如果有较多需要长期存活的对象的话，容易导致Full Gc 和 OOM。
* 提高 IHOP 的值。虽然降低了Mixed Gc 频率，单、但导致老年代存在过多对象，增加了每次老年代回收时"**并发标记**"阶段的计算负担和"**mixed gc**"阶段计算和预估的负担。不适合CPU负载较高的计算型业务系统。







### 4.日处理上亿数据的系统(分配内存区域大小)

优化原则：

在给定的内存大小合理的前提下，合理设置 eden、survivor、老年代的内存比例，尽可能让存活的对象放入到survivor区（下次Minor Gc就回收，不进入老年代），延长两次 Full gc之间的时间。



**要结合自己系统的运行，根据系统的内存占用情况，GC后的对象存活情况，合理分配 Eden、Survivor、老年代的内存大小，合理设置一些参数。**

![image-20210315092631519](https://gitee.com/iupikachu/img/raw/master/img/20210316103952.png)

**背景1:**

​	一分钟之后，新生区快满了，新生代对象总共大概1.2G,而老年代可用内存为1.5G，即便一次Minor gc后，全部对象都存活，老年代也能放得下，直接执行 Minor Gc。

​	假设100个计算任务都结束，还有20个计算任务总共200M数据还在计算中，200MB的对象是存活的，1Gb的对象是回收掉的。

​	但是因为 Survivor区只有100Mb的大小，这些数据无法放入Survivor区，所以只能进入老年代中了，这样子大概7分钟过后，1.4G对象进入老年代，老年代剩余空间不到100MB了。

​	第8分钟运行结束，新生代满了，老年代也不够，直接触发 Full Gc 。

​     平均7、8分钟一次Full Gc。性能很差。

**性能优化1**：

​	2GB给新生代 1GB给老年代 Survivor 大概200MB 刚好能放下Minor gc 后的对象了。





背景2：

​		这个中型电商系统在大促期间的瞬时高峰下单场景，假设大促高峰期间，每秒每台机器会有300个下单请求。每秒使用60MB内存，有一台4核8G的机器，应该如何合理给Jvm各个区域分配内存。

20多秒 eden区满了 Minor Gc 剩下大约 100MB的存活对象，进入 Survivor区。



**性能优化2：**

-XX:MaxTenuringThreshold =5 

这个参数让一两分钟内连续躲过5次Minor gc的对象迅速进入老年代。这种对象一般是一些@Service、@Controller之类的注解标注的系统业务逻辑组件。 



发生 Full gc 的触发条件。

* 没有打开 -XX:HandlePromotionFailure 结果老年代内存可用内存也就1G,新生代对象总大小最大可以有1.8G,那么Minor gc 前，一检查，"老年代可用内存" < "新生代总对象",导致每次Minor gc 前都触发Full gc。

jdk1.6以后废弃了 -XX:HandlePromotionFailure 

只要满足 每次Minor gc前  老年代可用内存空间 < 历代Minor gc后升入老年代的平均对象大小

就可以进入老年代了。

* 老年代可用内存空间 > 历代Minor gc后升入老年代的平均对象大小 
* 可能某次Minor gc 后要升入老年代的对象有几百MB,但是老年代可用空间不足。
* 设置了"-XX：CMSInitiatingOccupancyFaction" 参数，老年代使用空间超过了设定的92%,自行触发 Full gc。



可能会因为上面的条件任何一个满足，触发 Full gc。但是一般需要老年代几乎占满的时候，才会触发。



**思考: 这时老年代Full gc 会发生"Concurrent Mode Failure" ?**

​		CMS在并发清理的时候，系统程序是可以并发运行的，假设老年代大概有900MB的对象，剩余空间仅仅只有100MB了，此时系统程序还在不停地创建对象，万一这个时候系统运行触发了某个条件，比如说有200MB对象要进入老年代。此时就会触发 Concurrent Mode Failure ，因为此时老年代没有内存来放下这200MB对象。这时就会立马"stop the wold" ，然后切换CMS 为 Serial Old。直接禁止程序运行，单线程进行老年代垃圾回收，回收掉 900MB后，再让系统运行。

​	 但是发生的概率是比较小的，因为必须是 CMS 触发 Full gc的时候，系统运行区间还让200MB对象进入老年代。



**参数设置:**

![image-20210316103141121](https://gitee.com/iupikachu/img/raw/master/img/20210316103141.png)






今日分享： 线上机器CPU负载过高如何去排查？如何优化JVM参数？

（1）第一可以通过 top -Hp PID , jstack PID等查看占用CPU资源过高的线程是哪些？可能会看到是GC线程。
或者是其他线程，如果是GC线程，那么jstat查看JVM垃圾回收器工作的情况。如果是其他业务线程，可能需要跟踪栈信息，追踪到代码中进行分析。（可能是一直循环处理业务，数据量大，处理耗时。）
-- 业务线程导致CPU高的场景，没有关注过，不知道我的理解对不对。
（2）查看JVM垃圾回收情况相关的信息
YoungGC频率，YoungGC耗时，每次GC过后Eden+S0区的垃圾回收情况；进入老年代的大小
FullGC频率，YoungGC耗时，每次GC过后老年代的垃圾回收情况；
我的总结：
（1）如果是YoungGC，FullGC频繁，但是每次FullGC回收之后，垃圾回收率很高，可能就是高并发引起的；要关注下是不是年轻代内存分配不合理，是否需要加大JVM堆内存。升级机器等。根据YoungGC每次进入老年代的大小，重新预估一下，新生代需要分配多大的内存比较合适，来解决这个高并发引起的FullGC问题。
（2）如果FullGC之后，回收的内存时多时少，或者说很少，甚至可能出现连续的1-3次，回收之后，老年代剩余空间是在增长的，这个时候就要排除是否有发生内存泄漏的嫌疑。或者说高并发引起的问题导致对象无法被回收。这时候一般需要dump下内存快照，使用MAT工具分析内存快照，可以短时间连续dump两次，对比两次内存快照，查看哪些对象不断在增长。这些对象是不是大对象，因为并发问题无法被及时回收，JVM处在OOM边缘。然后根据派排查结果，优化代码问题。
优化JVM参数：
（1）优化新生代和老年代的占比。尽量保证每次YoungGC之后。可以打印对内存信息，计算一下一般存活对象是多大。假设是100M。那么可以将S0设置成 S0 * 50% = 100M。 S0大概需要200M。这样就可以把Eden和老年代大小预估出来了，一般业务系统。老年代分配1至2G就可以了。
（2）需要开启CMS垃圾回收器的对内存碎片进行整理。一般每次FullGC都整理一遍最好。
（3）-XX:CMSInitiatingOccupancyFraction=92。老年代占用92%以上发生FullGC。一般这个值我觉得偏大了，如果是高并发系统，会有较大可能出现Concurrent Mode Failure。所以我对CMS设置的时候，会把老年代预留空间大小预估到S0区大小这样。一般设置80%。对于这点不知道是否合理？
（4）还会设置一些额外的参数：-XX:-OmitStackTraceInFastThrow
还有打印GC日志，发生OOM的时候dump内存快照参数。
（5）还有一点，如果没有发生什么特殊的问题，不会对其他的参数进行优化。能简单设置就采用简单的设置。









### 5.日志分析



```java
public class Demo1 {
    public static void main(String[] args) {
        byte[] array1 = new byte[2*1024*1024];
        array1 = new byte[2*1024*1024];
        array1 = new byte[2*1024*1024];
        array1 = null;

        byte[] array2 = new byte[128*1024];
        byte[] array3 = new byte[2*1024*1024];

    }
}
```

![image-20210320160743587](JVM.assets/image-20210320160743587.png)



![image-20210320155547208](JVM.assets/image-20210320155547208.png)

















下次分享 ：你说你精通jvm调优，能够说下G1工作原理以及整体流程吗？